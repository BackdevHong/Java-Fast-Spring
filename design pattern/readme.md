# 디자인 패턴이란?

자주 사용되는 설계 패턴을 정형화 시켜서 이를 유형별로 가장 최적의 방법으로 개발을 할 수 있도록 정해둔 설계입니다.
기본적으로 **알고리즘**과 매우 유사하지만, 알고리즘같은 경우 해법이 존재합니다. 하지만 디자인 패턴은 명확한 해법이 정해져 있지는 않습니다.
현재 진행하는 프로젝트 구성, 상황에 따라 변경해서 적용할 수 있습니다.

# GOF 디자인 패턴이란?

가장 유명한 디자인 패턴입니다.
소프트웨어를 설계할 때는 기존에 비슷한 소프트웨어 구성, 프로젝트를 했던 경험이 필요합니다. 하지만 이런 경험을 모든 사람들이 다양하게 가질 수는 없습니다.
이러한 지식을 공유하기 위해 나온 것이 GOF(Gang of Four) 디자인 패턴입니다.

객체지향 개념에 따른 설계중 재사용이 필요한 경우에 유용하게 사용할 수 있도록 미리 디자인 패턴으로 정리해둔 것입니다.
이 GOF 디자인 패턴만 알고있어도 프로젝트를 진행할 때 손쉽게, 재사용이 유용하게 객체지향적인 설계에 적용시킬 수 있습니다.

GOF 디자인 패턴은 총 23개가 있습니다. 하지만 이 23개를 다 알 필요는 없습니다.
많이 쓰이고 있는 디자인 패턴만 알고 있어도 좋은 소프트웨어 설계를 할 수 있습니다.

# 디자인 패턴의 장점

- 모든 개발자가 디자인 패턴에 대해 이해도를 가지고 있다는 가정 하에 처음에 설계를 하거나 코딩을 진행할 때 개발자들간 원할한 소통이 가능합니다.
- 디자인 패턴 자체를 알고 있는 것만으로 우리가 개발하는 소프트웨어가 어떠한 구조로 개발이 되있는지 파악하기가 용이합니다.
- 디자인 패턴으로 개발을 해두면 어떠한 기능이 추가된다거나, 새로운 부분을 개발할 떄 기존에 있던 컴포넌트, 클래스를 재사용하면서 개발시간 단축이 가능합니다.
- 설계변경에 따른 유용한 대처가 가능합니다.

# 디자인 패턴의 단점

- 객체지향적인 설계를 해야 하고, 구현을 해야합니다. 결국, 모든 개발자가 객체지향을 잘 이해해야 합니다.
- 초기에 설계하고 코딩하는 부담이 들어갑니다. 절차지향과 클래스 프로토타입과는 달리 인터페이스, 추상클래스 등등 여러가지 구조를 작성해야 하기 때문에 개발 시간은 조금 더 들어가게 됩니다.
  - 하지만, 한번 디자인 패턴으로 개발을 해두게 된다면 재사용, 설계변경, 기능추가에 유연하게 대처가 가능합니다.

# 디자인 패턴에 종류

디자인 패턴중에는 여러가지 패턴이 있습니다.
위에서 말한 GOF 패턴은 크게 3가지로 나눌 수 있습니다.
**굵은체로 표시된 패턴은 실제로 알아볼 패턴입니다.**

## 생성 패턴

주로 생성자와 관련된 패턴입니다.
객체를 생성과 변경에 대해서 전체 시스템에 미치는 영향을 최소화, 코드의 유연성을 높여줍니다.

- Factory Method
- **Singleton**
- Prototype
- Builder
  - 프로젝트 할 때 알아볼 예정입니다.
- Abstract Factory
- Chaining
  - GOF 패턴은 아니지만, 실제로 코딩할때 많이 사용할 디자인 패턴이다.
  - Lombok을 통해 설정해서 사용한다.

## 구조 패턴

프로그램 내에 자료구조, 인터페이스 구조 등 프로그램 구조를 설계하는데 활용될 수 있는 패턴입니다.
클래스, 객체들의 구성을 통해 더 큰 구조 확장을 하는데 도움이 되는 패턴들입니다.
큰 규모의 시스템에서는 많은 클래스들이 서로간의 의존성을 가지게 되는데 그렇다 보면 시스템이 커지거나, 다른 클래스가 생성되거나, 클래스를 수정하다 보면 서로 의존성이 많다보니 수정하는 부분이 복잡하게 나올 수 있습니다. 이러한 부분들을 복잡하지 않고, 유지보수하기 쉽도록 만들어주는 패턴입니다.

- **Adapter**
- Composite
- Bridge
- **Decorator**
- **Facade**
- Flyweight
- **Proxy**

## 행위 패턴

반복적으로 사용되는 객체들의 상호작용을 패턴화한 패턴입니다.
클래스나 객체들이 상호작용하는 방법과 책임을 분산시키는 방법을 제공합니다.
행위 패턴은 행위 관련 패턴을 사용해서 독립적으로 일을 처리하고자 할 때 사용합니다.

- Template Method
- Interpreter
- Iterator
- **Observer**
- **Stretegy**
- Visitor
- Chain of responsibility
- Command
- Mediator
- State
- Memento

# 싱글톤 패턴
싱글톤 패턴은 어떤 클래스 또는 객체가 유일하게 1개만 존재해야 할 떄 사용하는 패턴입니다.<br>
주로 사용하는 곳은 서로 자원을 공유할 떄 사용합니다. 

실물 세계에서는 프린터기 같은 종류가 해당됩니다.<br>
여러대의 PC가 하나의 프린터기 혹은 복사기를 사용할 때 사용하는 패턴이라고 볼 수 있습니다.<br>

실제 프로그래밍에서는 TCP 소켓 통신을 할때 서버와 연결된 connect 객체가 해당된다. 

스프링같은 경우 Bean이라 부르는 클래스 혹은 객체들은 싱글톤으로 관리해야 합니다.

## 싱글톤 패턴의 방식
- 기본 생성자를 private로 막아버립니다.
- ``getInstance()`` 라는 메서드를 통해서 생성된 객체를 가져오거나, 객체가 없는 경우 새로 생성합니다.
- 어떠한 클래스에 써서라도 static 메서드를 통해 ``getInstance()``를 했었을 떄 동일한 객체를 얻을 수 있습니다.


# 어뎁터 패턴
어뎁터 패턴같은 경우 우리가 주변에서 많이 볼 수 있는 패턴입니다.
호환성이 없는 기존 클래스의 인터페이스를 변환해서 코드를 수정할 필요 없이 재사용이 가능하게 해줍니다.

SOLID중 개방폐쇄 원칙(OCP)을 따르고 있죠.

실생활에서는 100v를 220v로 바꿔주거나, 그 반대같은 경우가 해당합니다. 흔히 얘기하는 돼지코라고 부를 수 있습니다.

# 프록시 패턴
Proxy같은 경우 대리인이라는 뜻으로써, 뭔가를 대신해서 처리하는 것입니다.
Proxy Class를 통해 대신 전달하는 형태로 설계되며, 실제 Client같은 경우 Proxy로부터 결과를 받습니다.

Cache의 기능으로도 활용이 가능합니다. 실제로 스프링에서는 AOP에서 프록시 패턴을 사용하고 있습니다.

SOLID중 개방폐쇄 원칙(OCP)와 의존 역전 원칙 (DIP)를 따르고 있죠.

# 데코레이터 패턴
데코레이터 패턴은 기본 뼈대 클래스는 유지하되, 이후 필요한 형태를 꾸밀 때 사용합니다.
확장이 필요한 경우 상속의 대안으로도 활용하죠.

SOLID중 개방폐쇄 원칙(OCP)와 의존 역전 원칙 (DIP)를 따르고 있죠.

현실세계에서도 쉽게 찾아볼 수 있는 경우의 패턴입니다.
- 커피
  - 에스프레소 + 물 = 아이스 아메리카노
  - 아이스 아메리카노 + 우유, 그 외에것 = 카페라때
  - 커피 원액 + 다른 재료 = 다른 결과
- 빵
  - 빵 + 초코 = 초코빵
  - 빵 + 딸기 = 딸기빵
  - 빵 + 과일 = 과일빵
  
즉, 원본은 유지하되 어떤 재료를 첨가하는가에 따라 확장이 된다는 것이죠.

# 옵저버 패턴
관찰자 패턴이라고도 합니다. 변화가 일어 났을 때, 미리 등록된 다른 클래스에 통보해주는 패턴을 구현한 것입니다.

주로 스윙, 자바 GUI 프로그래밍 또는 안드로이드 프로그래밍을 할 때 이벤트 리스너(event listener)를 달게 되어 있습니다. 이 이벤트 리스너가 옵저버 패턴에 표준적인 예라고 볼 수 있죠.

현실 세계에서는 교실같은 곳에서 아이 한명이 망을 보다 선생님이 오신다는 것을 알렸을 때 중간에 있는 아이 한명(이벤트 리스너)이 모두에게 미리 등록되어 있는 친구들에게 알려주는 것이라고 볼 수 있습니다.

# 파사드 패턴

파사드 패턴은 건물의 앞쪽 정면이라는 뜻을 가집니다.
여러 개의 객체와 실제 사용하는 서브 객체의 사이에 복잡한 의존관계가 있을 때, 중간에 facade 라는 객체를 두고, 여기서 제공하는 인터페이스만을 활용하여 기능을 사용하는 방식입니다.

파사드는 자신이 가지고 있는 각 클래스의 기능, 어떤 인터페이스로 제공할 지 명확하게 알아야 합니다.

주로 코딩할 때 많이 사용하기도 하고, 여러 개의 객체를 합쳐서 특정한 기능을 만들 때 사용합니다.

예시로는 FTP 클라이언트를 들 수 있습니다.

